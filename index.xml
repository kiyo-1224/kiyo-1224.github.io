<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>忆遇惜·真白 的个人博客</title>
    <link>https://kiyo-1224.github.io/</link>
    <description>Recent content on 忆遇惜·真白 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Jun 2022 01:10:00 +0800</lastBuildDate><atom:link href="https://kiyo-1224.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JDBC概述和获取数据库连接</title>
      <link>https://kiyo-1224.github.io/posts/jdbc1/</link>
      <pubDate>Sat, 18 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/jdbc1/</guid>
      <description>JDBC概述 持久化 Java中的数据存储技术 在Java中，数据库存取技术可分为如下几类：
 JDBC 直接访问数据库 JDO(Java Data Object)技术 第三方O/R工具，如Hibernate、MyBatis等 JDBC是Java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC  JDBC介绍  JDBC(Java DataBase Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口(一组API)，定义了用来访问数据库的标准Java类库，(java.sql,javax.sql) 使用这些类库可以以一种标准的方法、方便地访问数据库资源 JDBC 为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题 JDBC的目标是使Java程序员使用 JDBC 可以连接任何提供了 JDBC 驱动程序的数据库系统，使得程序员无需对特定的数据库系统的特点做过多的了解，以简化和加快开发过程   JDBC 体系结构 JDBC接口(API)包含两个层次：
 面向应用的API：Java API，抽象接口，供应用程序开发人员使用(连接数据库，执行SQL语句，获得结果) 面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用  JDBC是 sun 公司提供的一套用于数据库操作的接口，程序员只需面向此接口编程即可，不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现集合，即为不同数据库的驱动
JDBC 程序的编写过程 补充：ODBC(Open DataBase Connectivity,开放式数据库连接)，是微软在 Windows 平台推出的。使用者在程序中只需调用 ODBC API，由 ODBC 驱动程序将调用转换为对特定的数据库的调用请求
 获取数据库连接 要素一： Driver 接口实现类 Driver接口介绍 java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口 在程序中不需要直接去访问实现 Driver 接口的实现类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现
加载与注册驱动 加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</description>
    </item>
    
    <item>
      <title>事务处理、Druid连接池和DBuitl</title>
      <link>https://kiyo-1224.github.io/posts/jdbc3/</link>
      <pubDate>Sat, 18 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/jdbc3/</guid>
      <description>数据库事务 数据库事务介绍  事务：一组逻辑操作单元，使数据从一种状态变换到另一种状态 一组逻辑单元：一个或多个 DML 操作 事务处理：保证所有事务都作为一个工作单元来执行，即是出现了故障，都不能改变这种执行方式。当一个事务中执行多个操作时，要么所有的事务都被提交(commit),那么这些修改就永久的保存下来；要么数据库管控系统将放弃所作的所有修改，整个事务**回滚(rollback)**到最初状态，数据一旦提交，就不可回滚 自动提交操作：DDL 操作、DML(可设置取消自动提交)、关闭连接时 为确保数据库中数据的一致性，数据的操作应当是离散的成组的逻辑单元；当它全部完成时，数据的一致性可以保存，而这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点的操作应当全部回退到开始状态  JDBC 事务处理 获取到数据库连接后设置关闭自动提交，在所有 sql 都正常执行就提交，否则回滚
例： 事务的 ACID 属性 原子性(Atomicity): 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生
一致性(Consistency): 事务必须使数据库从一个一致性状态变换到另一个一致性状态
隔离性(Isolation): 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰
持久性(Durability): 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响
 数据库的并发问题 脏读：对于两个事务 T1、T2，T1 读取了已经被 T2 更新但还没有被提交的字段。之后若 T2 回滚，T1 读取的内容就是临时且无效的
不可重复读：对于两个事务 T1、T2，T1 读取了一个字段，然后 T2 更新了该字段。之后 T1 再次读取同一个字段，值就不同了
幻读：对于两个事务 T1、T2，T1 从表中读取了一个字段，然后 T2 在该表中插入了一些新的行。之后如果 T1 再次对其同一个表，就会多出几行
数据库事务的隔离性：数据库系统必须具有隔离并发运行各个事务的能力，使它们不会互相影响，避免各个并发问题
 数据库的隔离级别 一个事务与其他事务隔离程度称为隔离级别。数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性越好，但并发性越弱
四种隔离级别 Oracle 支持的两种事务隔离级别：READ COMMITED(默认)、SERIALIZABLE
MySQL 支持以上四种 默认为： REPEATABLE READ
 设置隔离级别 使用 getTransactionIsolation() 获取数据库隔离级别 使用 setTransactionIsolation() 设置数据库隔离级别</description>
    </item>
    
    <item>
      <title>使用PerparedStatement实现CRUD操作</title>
      <link>https://kiyo-1224.github.io/posts/jdbc2/</link>
      <pubDate>Sat, 18 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/jdbc2/</guid>
      <description>使用PerparedStatement实现CRUD操作 操作和访问数据库 数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个 Socket 连接
在java.sql包中有三个接口分别定义了对数据库的调用的不同方式
 Statement：用于执行静态 SQL 语句并返回它所生成结果的对象 PrepatedStatement：SQL 语句被预编译并储存在此对象中，可以使用此对象多次高效的执行该语句 CallableStatement：用于执行 SQL 存储过程  使用 Statement 操作数据表的弊端 通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回结果；
Statement 接口定义了下列方法用于执行 SQL 语句
 int excuteUpdate(String sql) ：执行更新操作 INSERT、UPDATE、DELETE ResultSet executeQuery(String sql)：执行查询操作 SELECT  但是使用Statement操作数据表存在弊端
 存在拼串操作，繁琐 存在 SQL 注入问题  SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意注入行为的做法
对于Java而言，要防范SQL注入，只要用PreparedStatement(从Statement扩展而来)取代Statement即可
PreparedStatement 的使用 在使用 PreparedStatement 之前，需要先获取数据库连接，然后再预编译 sql 语句，获得 PreparedStatement 实例，如果有使用占位符，再填充占位符，然后执行操作，最后关闭资源。
以插入为例：  封装数据库的连接和关闭操作 对于需要重复使用的连接和关闭操作可以将其进行封装</description>
    </item>
    
    <item>
      <title>JdbcTemplate和事务操作</title>
      <link>https://kiyo-1224.github.io/posts/jdbctemplate/</link>
      <pubDate>Fri, 17 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/jdbctemplate/</guid>
      <description>JdbcTemplate和事务操作 JdbcTemplate JdbcTemplate(概念和准备) 概念：
JdbcTemplate Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作
准备工资 导入相关依赖
 &amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.2.9&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;8.0.29&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;5.3.20&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;5.3.20&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;spring-orm&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;4.3.21.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
 配置数据库连接池 配置 JBDCTemplate 对象，注入 DataSource 创建 service、dao类,在 dao 注入 JDBCTemplate 对象 ，并且在配置文件中开启组件扫描
JdbcTeplate 操作数据库 首先创建相应的实体类，随后在service Dao类中添加相应的方法，最后使用测试类进行测试 例： 增删改使用 jdbcTemplate 中的 update 方法 查询使用 queryForObject 或 query 方法
对于返回对象或集合的查询，需要使用其重载的方法，其参数为： (sql语句，RowMapper&amp;lt;T&amp;gt;,sql语句值)
其中 RowMapper 是接口，针对返回不同类型数据，使用此接口的实现类完成数据封装</description>
    </item>
    
    <item>
      <title>AOP</title>
      <link>https://kiyo-1224.github.io/posts/aop/</link>
      <pubDate>Fri, 10 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/aop/</guid>
      <description>AOP(面向切面编程) 什么是AOP: 面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率（即不通过修改源代码方式，在主干功能里添加新功能）
AOP底层原理：
 有接口,使用 JDK 动态代理。创建接口实现类代理对象，增强类的方法 无接口,使用 CGLIB 动态代理。创建子类的代理对象，增强类的方法  AOP(JDK 动态代理) 使用 JDK 动态代理，需要使用 Proxy 类里面的方法创建代理对象
代理类 需要实现 InvocationHandler 接口，首先使用有参构造传递需要代理的对象，然后在 invoke 方法中编写增强的逻辑 例： 编写完代理类后，使用 newProxyInstance 启用代理， 此方法有三个参数 第一个参数：类加载器 第二个参数：增强方法所在的类，这个类的接口，支持多个接口 第三个参数：代理类对象 例： AOP(操作术语) 连接点：类里面哪些方法可以被增强，这些方法被称为连接点
切入点：实际被增强的方法，称为切入点
通知(增强)：实际增强的逻辑部分称为通知(增强) 通知有多种类型：前置通知、后置通知、环绕通知、异常通知、最终通知
切面：是动作，把通知应用到切入点的过程
AOP操作 Spring 框架一般是基于 AspectJ 实现 AOP 操作
AspectJ：AspectJ 不是 Spring 组成部分，是一个独立的 AOP 框架，一般和 Spring 一起使用，进行 AOP 操作
基于 AspectJ 实现 AOP 操作有两种 1.基于 xml 配置文件实现 2.基于注解方式实现
需要在工程项目中引入 AOP 相关依赖
 &amp;lt;dependency&amp;gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;指针基础</title>
      <link>https://kiyo-1224.github.io/posts/c&#43;&#43;pointbase/</link>
      <pubDate>Fri, 10 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/c&#43;&#43;pointbase/</guid>
      <description>指针 指针的基本内容 指针本身是一个变量，其储存值的地址，而不是值。因此我们使用 *操作符声明一个指针变量，使用地址操作符 (&amp;amp;) 来获取常规变量的地址。 例：
 int i = 10;
int *point = &amp;amp;i;
int j = *point;
 其中 &amp;amp;i 是 i 的地址值，指针名 point 表示地址 可以使用 * (解除引用操作符) 来获取该地址处储存的值，但需要注意的是在对一个指针使用解除引用操作符前，该指针一定要被初始化为一个确定的地址值。
我们可以将常规变量想象为一个硬币，一面为值，另一面为地址。值为指定量而地址为派生量
内存的动态开辟与释放 new 关键字 对于指针，C++ 通过指针实现重要的 OOP 技术——在程序运行时分配内存 指针可以在运行阶段分配未命名的内存以存储值，在这种情况下只能使用指针来访问内存。 在C++ 中使用 new 关键字分配内存，new 将找到一个长度正确的内存块，并返回该内存块的地址，我们需要将该地址赋予一个指针
 int *prts = new int;
 由于 prts 指向的内存空间没有名字，我们说 prts 指向一个数据对象，此对象并不是面向对象中的对象，它指的是为数据项分配的内存块。变量是一个数据对象，但 prts 指向的内存并不是一个变量
delete 关键字 每次一个 new 开辟一个内存空间都会消耗内存，如果不对内存进行释放，内存一旦消耗殆尽，计算机将无法满足 new 请求，此时 new 将返回 0。对于值为 0 的指针我们称作为空指针，C++ 确保空指针不会指向一个有效的数据</description>
    </item>
    
    <item>
      <title>IOC容器</title>
      <link>https://kiyo-1224.github.io/posts/ioc/</link>
      <pubDate>Fri, 10 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/ioc/</guid>
      <description>IOC的概念 IOC(控制反转)，把对象创建和对象之间的调用过程，交给Spring进行管理，其目的为降低耦合度
IOC底层使用：xml解析、工厂模式、反射
 IOC接口(BeanFactory) Spring 提供IOC容器实现方式有两种：
 BeanFactory：IOC容器基本实现，是spring内部使用的接口，加载配置文件时不会创建对象，在获取对象才去创建 ApplicationContext：BeanFactory接口的子接口，提供更多的功能，加载文件时就会创建对象  ApplicationContext实现类：
 FileSystemXmlApplicationContext :读取文件绝对路径 ClassPathXmlApplicationContext	:读取文件类路径  通常使用 ApplicationContext 接口来获取配置文件 例：
 ApplicationContext context =
new ClassPathXmlApplicationContext(&amp;ldquo;bean.xml&amp;rdquo;);
  IOC操作Bean管理(基于xml) Bean管理指的是两个操作：1.Spring创建对象 2.Spring注入属性
 1.基于xml配置文件实现 在Spring配置文件中使用bean标签，标签里添加对应属性，就可以实现对象创建
bean标签常用属性
 id 属性：唯一标识 class 属性：类全路径   &amp;lt;bean id=&amp;ldquo;user&amp;rdquo; class=&amp;ldquo;pojo.user&amp;rdquo;&amp;gt; &amp;lt;/bean&amp;gt;
 创建对象时，默认执行无参构造方法完成对象的创建
使用 getBean 方法获取对象，其形参列表为(id值，类)
 User user = context.getBean(&amp;ldquo;user&amp;rdquo;,User.class)
  2.基于xml注入属性 DI：依赖注入，即注入属性
 name 填入属性名 使用set方法注入，在&amp;lt;bean&amp;gt;标签中使用&amp;lt;property&amp;gt;，配置属性注入 使用有参构造方法注入,在&amp;lt;bean&amp;gt;标签中使用&amp;lt;constructor-arg&amp;gt;，配置属性注入  set 方法注入</description>
    </item>
    
    <item>
      <title>this Blog Web</title>
      <link>https://kiyo-1224.github.io/posts/me/</link>
      <pubDate>Wed, 01 Jun 2022 01:07:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/me/</guid>
      <description>关于此博客 此博客将用于上传我的个人技术博客以及绘画的作品</description>
    </item>
    
    <item>
      <title>Links</title>
      <link>https://kiyo-1224.github.io/links/</link>
      <pubDate>Wed, 01 Jun 2022 01:02:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/links/</guid>
      <description>本页面为友情链接页面。申请友链请联系我：iyu_mashiro@163.com</description>
    </item>
    
    <item>
      <title>hugo博客的搭建</title>
      <link>https://kiyo-1224.github.io/posts/newhugopage/</link>
      <pubDate>Wed, 01 Jun 2022 00:17:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/newhugopage/</guid>
      <description>Welcom  Welcom to iyu_mashiro&amp;rsquo;s Blog感谢您花费宝贵的时间前来阅读我的第一篇博客，这篇博客是我在搭建好博客之后，对于搭建个人博客所做的记录，希望能帮助到您,如果文章内容有错误，请发送邮件至：iyu_mashiro@163.com 我将不胜感激
前言  此篇博客为我的第一篇博客，原本只耗费了一个小时便完成了博客的基本搭建，但因后续对主题设置的不满，便对主题进行了修改导致后续出现了一系列的问题，使得我最终花费了六个小时才完善博客的搭建
初次搭建个人博客 使用 Hugo+github 部署的方案 通过 Hugo 可以快速搭建静态网站,然后将其部署到GitHub上，使其可以在公网访问到
搭建流程 0.前置 在搭建博客之前需要先完成 git 安装与配置，并且设置好用户名和电子邮件，否则后续的步骤将无法进行
1. Hugo文件下载 在使用 hugo 之前，需要先在 Hugo 官网下载 hugo.exe 文件 地址为： https://www.gohugo.org/
2. Hugo 环境变量配置 下载完成之后，需要对环境变量进行配置，否则将无法识别 hugo指令，只需将 hugo.exe 路径加入 path 中即可完成环境变量的配置
 win10 右键此电脑 -&amp;gt; 属性 -&amp;gt; 高级系统设置 -&amp;gt; 环境变量 -&amp;gt; 系统变量 -&amp;gt; path -&amp;gt; 添加即可
 3.生成站点 使用 Hugo 快速生成站点
 hugo new site path //path 为站点生成的路径 cd path //进入目录</description>
    </item>
    
    <item>
      <title>hugo博客的更新</title>
      <link>https://kiyo-1224.github.io/posts/addblogcontent/</link>
      <pubDate>Wed, 01 Jun 2022 00:17:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/addblogcontent/</guid>
      <description>博客的更新 在更新了博客的内容之后，我们需要对远端也进行一次更新操作
0.预览博客的更新内容 在博客根目录下，使用命令对更新的内容进行预览
 hugo server --theme=你的主题名 --buildDrafts
 确定无误后开始更新操作
1.初始化博客，更新public目录 在博客根目录下，使用 hugo 命令即可初始化博客并更新public目录
 hugo
hugo --theme=你的主题名 --baseUrl=&amp;ldquo;url&amp;rdquo; //url为之前创建的仓库名 --buildDrafts
 2.提交并更新 首先需要进入 public 目录下 然后执行更新和提交操作
 cd public
git add -A
git commit -m &amp;ldquo;提交说明&amp;rdquo;
git remote set-url origin https://token @github.com/GitHub用户名/仓库名.git
git push -f origin master
 至此即可完成更新操作</description>
    </item>
    
    <item>
      <title>Page</title>
      <link>https://kiyo-1224.github.io/page/</link>
      <pubDate>Tue, 31 May 2022 23:41:50 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/page/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Archives</title>
      <link>https://kiyo-1224.github.io/archives/</link>
      <pubDate>Sat, 20 Apr 2019 13:29:27 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
