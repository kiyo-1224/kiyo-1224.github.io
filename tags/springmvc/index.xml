<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SpringMVC on 忆遇惜·真白 的个人博客</title>
    <link>https://kiyo-1224.github.io/tags/springmvc/</link>
    <description>Recent content in SpringMVC on 忆遇惜·真白 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 23 Jun 2022 01:10:00 +0800</lastBuildDate><atom:link href="https://kiyo-1224.github.io/tags/springmvc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SpringMVC RESTFul</title>
      <link>https://kiyo-1224.github.io/posts/springmvc4/</link>
      <pubDate>Thu, 23 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/springmvc4/</guid>
      <description>RESTFul RESTFul 简介 REST：Representational State Transfer,表现层资源状态转移
资源：
资源是一种看待服务器的方式。即，将服务器看作是由很多离散的资源组成，每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象概念，所以它不仅仅能代表服务器文件系统中的一个文件，数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个 URI 来标识。URI即是资源的名称，也是资源在 web 上的地址。对某个资源感兴趣的客户端应用，可以通过资源的 URI 与其进行交互
资源的表述：
资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移(交换)。资源的表述可以有多种格式，如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式
状态转移：
状态转移说的是：在客户端和服务器之间转移(transfer)代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的
RESTFul 的实现 具体的说，就是 HTTP 协议里，四个表示操作方式的动词：GET、POST、PUT、DELETE
分别对应四种基本操作：获取资源，新建资源，更新资源，删除资源
REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性 HiddenHttpMethodFilter 需要先在 web.xml 下进行配置，注意此过滤器需要在字符编码过滤器之后，因为在设置编码之前一旦获取了任何请求参数，设置编码将没有任何效果 以 put 请求为例: RESTFul 案例 注意如果需要使用静态资源，需要在 SpringMVC 的配置文件中开启对静态资源的访问 查： 删： 改： 增： 页面：
user主页面 user添加页面 user更改界面 </description>
    </item>
    
    <item>
      <title>域对象共享数据和SpringMVC的视图</title>
      <link>https://kiyo-1224.github.io/posts/springmvc3/</link>
      <pubDate>Thu, 23 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/springmvc3/</guid>
      <description>域对象共享数据 使用 servlet 向 request 域对象共享数据 例： 使用 ModelAndView 向request 域共享对象 使用 ModelAndView 此方法必须以 modelAndView 为返回值类型
例： 使用 Model 向 request 域对象共享数据 需要在形参中创建 Model 类型的形参
例： 使用 map 向 request 域对象共享数据 需要在形参中创建 Map 类型的形参
例： 使用 ModelMap 向 request 域对象共享数据 需要在形参中创建 ModelMap 类型的形参
例： Model、ModelMap、Map 的关系 Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型 向 session 域共享数据 对于 session 更加推荐使用 servlet 原生 API
例： 向 application 域共享数据 例： SpringMVC的视图 SpringMVC 中的视图是 view 接口，视图的作用是渲染数据，将模型 Model 中的数据展示给用户</description>
    </item>
    
    <item>
      <title>SpringMVC_RequestMapping 注解</title>
      <link>https://kiyo-1224.github.io/posts/springmvc1/</link>
      <pubDate>Wed, 22 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/springmvc1/</guid>
      <description>环境搭建 第一步导入相关依赖，并设置打包方式为 war 第二步在工程中添加 web 模块，并在配置文件中配置前端控制器 第三步在配置文件中配置 thymeleaf 和 注解扫描 第四步在 WEB-INF 下创建 temlates 目录然后在该目录创建 index.html 并在页面中引入 thymeleaf 命名空间 第五步创建控制器 最后启动 Tomcat 访问
@RequestMapping 注解 @RequestMapping 注解的功能 @RequestMapping 注解的作用是将请求和处理请求的控制器方法关联起来，建立映射关系，SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求
@RequestMapping 注解的位置 @RequestMapping 标识一个类：设置映射请求的请求路径的初始信息
@RequestMapping 标识一个方法：设计映射请求的请求路径的具体信息
@RequestMapping 注解的 value 属性 @RequestMapping 注解的 value 属性通过请求的请求地址匹配请求映射
@RequestMapping 注解的 value 属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求
@RequestMapping 注解的 value 属性必须设置
@RequestMapping 注解的 method 属性 @RequestMapping 注解的 method 属性通过请求的请求方式 (get 或 post) 匹配请求
@RequestMapping 注解的 method 属性是一个 RequestMethod 类型的数组，表示该请求能够匹配多种请求方式的请求</description>
    </item>
    
    <item>
      <title>SpringMVC获取请求参数</title>
      <link>https://kiyo-1224.github.io/posts/springmvc2/</link>
      <pubDate>Wed, 22 Jun 2022 01:10:00 +0800</pubDate>
      
      <guid>https://kiyo-1224.github.io/posts/springmvc2/</guid>
      <description>SpringMVC获取请求参数 通过 servletAPI 获取 将 HttpServletRquest 作为控制器方法的形参，此时 HttpServletRequest 类型的参数表示封装了当前请求的请求报文对象 例： 通过控制器方法的形参获取参数 在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在 DisPathcherServlet 中就会将请求参数赋值给相应的形参
例： 若：
请求参数所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串或字符串数组类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的参数，此参数的值为每个数据中间使用逗号拼接的结果
@RequestParam @RequestParam 是将请求参数和控制器方法的形参创建映射关系
@RequestParam 注解一共有三个属性：
value：指定为形参赋值的请求参数名
required：指定为形参赋值的请求参数的参数名，默认为 true
若设置为 true 时，则当前请求必须传递 value 所指定的请求参数，若没有传输请求参数，且没有设置 defaultValue 属性，则页面报错 400；
若设置为 false，则当前请求不是必须传输 value 所指定的请求传输，若没有传输，则注解标识的形参的值为 null
defaultValue：不管 required 属性值为 true 或 false，当 value 所指定的请求参数没有传输时，则使用默认形参为形参赋值
例： @RequestHeader @RequestHeader 是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader 注解一共有三个属性：value、required、defaultValue,用法和 @RequestParam 相同
@CookieValue @CookieValue 是将 cookie 数据属性和控制器方法的形参创建映射关系 @CookieValue 注解一共有三个属性：value、required、defaultValue,用法和 @RequestParam 相同
通过 POJO 获取数据 可以在控制器方法的形参位置设计一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值
处理请求参数乱码的问题 解决获取请求参数的乱码问题，可以使用 SpringMVC 提供的编码过滤器 CharacterEncodingFilter，但是必须在 web.</description>
    </item>
    
  </channel>
</rss>
